trigger:
- master

parameters:
  - name: integrationEnv
    displayName: Integration Environment
    type: string
    default: 'dev'
    values:
      - 'sbox'
      - 'dev'
      - 'test'
      - 'ithc'
      - 'stg'
      - 'prod'

  - name: blockDataLoss
    displayName: Block possible data loss
    type: string
    default: 'true'
    values:
      - 'true'
      - 'false'

  - name: dropObjects
    displayName: Drop objects not present in dacpac
    type: string
    default: 'false'
    values:
      - 'false'
      - 'true'

  - name: runBootstrap
    displayName: Run the bootstrap script
    type: string
    default: 'false'
    values:
      - 'false'
      - 'true'

variables:
  # ==== CHANGE THESE TO MATCH YOUR PROJECT ====
  sqlProjPath: 'metadata/metadata.sqlproj'       # path to your .sqlproj from repo root
  sqlProjDirectory: 'metadata'                   # folder that contains the .sqlproj
  dacpacName: 'metadata.dacpac'                  # output dacpac file name (AssemblyName.dacpac)
  artifactName: 'metadata-dacpac'

stages:
# ===========================
# 1. BUILD – create dacpac
# ===========================
- stage: Build
  displayName: 'Build metadata DACPAC'
  jobs:
  - job: BuildDb
    displayName: 'Build SQL project'
    pool:
      vmImage: 'windows-latest'

    steps:
    - checkout: self

    - task: DotNetCoreCLI@2
      displayName: 'Build $(sqlProjPath)'
      inputs:
        command: 'build'
        projects: '$(sqlProjPath)'
        arguments: '--configuration Release'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish DACPAC artifact'
      inputs:
        PathtoPublish: '$(Build.SourcesDirectory)/$(sqlProjDirectory)/bin/Release'
        ArtifactName: '$(artifactName)'
        publishLocation: 'Container'

# ===========================================
# 2. DEPLOY – to chosen Fabric environment
# ===========================================
- stage: Deploy
  displayName: 'Deploy to Fabric SQL DB'
  dependsOn: Build
  variables:
    EnvName: ${{ parameters.integrationEnv }}
  jobs:
  - job: DeployDb
    displayName: 'Publish DACPAC to Fabric $(EnvName)'
    pool:
      vmImage: 'windows-latest'

    steps:
    - checkout: none

    - task: DownloadBuildArtifacts@0
      displayName: 'Download DACPAC artifact'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: '$(artifactName)'
        downloadPath: '$(Pipeline.Workspace)'
   # 1) Install .NET 8 RUNTIME (what sqlpackage needs)
    - task: UseDotNet@2
      displayName: 'Install .NET 8 runtime for sqlpackage'
      inputs:
        packageType: 'runtime'
        version: '8.0.x'          # any 8.0.* is fine, SDK will roll patch forward
        includePreviewVersions: true

    # 2) (optional but useful) show which dotnet we're actually using
    - task: PowerShell@2
      displayName: 'Show dotnet info'
      inputs:
        targetType: 'inline'
        script: |
          dotnet --info
          dotnet --list-runtimes
          
    - task: PowerShell@2
      displayName: 'Install SqlPackage (.NET global tool)'
      inputs:
        targetType: 'inline'
        script: |
          dotnet tool install --global Microsoft.SqlPackage
          $sqlPackagePath = "$env:USERPROFILE\.dotnet\tools\sqlpackage.exe"
          if (-not (Test-Path $sqlPackagePath)) {
            throw "SqlPackage not found at $sqlPackagePath"
          }
          Write-Host "SqlPackage installed at $sqlPackagePath"

    - task: PowerShell@2
      displayName: 'Deploy DACPAC to Fabric $(EnvName)'
      inputs:
        targetType: 'inline'
        script: |
          $sqlPackagePath = "$env:USERPROFILE\.dotnet\tools\sqlpackage.exe"

          $artifactRoot = "$(Pipeline.Workspace)\$(artifactName)"
          if (-not (Test-Path $artifactRoot)) {
            throw "Artifact root not found at $artifactRoot"
          }

          $dacpacPath = Join-Path $artifactRoot "$(dacpacName)"
          if (-not (Test-Path $dacpacPath)) {
            # fallback – find first *.dacpac if name changes
            $dacFile = Get-ChildItem -Path $artifactRoot -Recurse -Filter *.dacpac | Select-Object -First 1
            if (-not $dacFile) {
              throw "No .dacpac found under $artifactRoot"
            }
            $dacpacPath = $dacFile.FullName
          }

          Write-Host "Using DACPAC: $dacpacPath"

          # Expect variable FABRIC_SQL_CONNSTRING_<env>, e.g. FABRIC_SQL_CONNSTRING_dev
          $envName = "$(EnvName)"
          $varName = "FABRIC_SQL_CONNSTRING_{0}" -f $envName
          $connString = (Get-Item "env:$varName").Value

          if (-not $connString) {
            throw "Environment variable $varName (Fabric SQL connection string) is not set."
          }

          $blockDataLoss = "${{ parameters.blockDataLoss }}" -eq "true"
          $dropObjects   = "${{ parameters.dropObjects }}"   -eq "true"
          $runBootstrap  = "${{ parameters.runBootstrap }}"  -eq "true"

          $args = @(
            "/Action:Publish"
            "/SourceFile:$dacpacPath"
            "/TargetConnectionString:$connString"
            "/p:AllowIncompatiblePlatform=true"
            "/p:BlockOnPossibleDataLoss=$($blockDataLoss.ToString().ToLower())"
          )

          if ($dropObjects) {
            $args += "/p:DropObjectsNotInSource=true"
          }

          # SqlCmd variables used in your scripts
          $args += "/v:environment=$envName"
          $args += "/v:Version=$(Build.BuildNumber)"

          Write-Host "Running sqlpackage with args:"
          $args | ForEach-Object { Write-Host "  $_" }

          & $sqlPackagePath @args

          if ($LASTEXITCODE -ne 0) {
            throw "sqlpackage failed with exit code $LASTEXITCODE"
          }

          Write-Host "DACPAC publish to Fabric $envName completed."

          if ($runBootstrap) {
            $bootstrapPath = Join-Path $artifactRoot ("__Bootstrap\initial-{0}.sql" -f $envName)
            if (Test-Path $bootstrapPath) {
              Write-Host "runBootstrap=true, executing $bootstrapPath"

              try {
                if (-not (Get-Module -Name SqlServer -ListAvailable)) {
                  Install-Module -Name SqlServer -Scope CurrentUser -Force -AllowClobber
                }
                Import-Module SqlServer -ErrorAction Stop
              }
              catch {
                Write-Warning "Could not install/import SqlServer module. Bootstrap will NOT run. $_"
                return
              }

              Invoke-Sqlcmd -ConnectionString $connString -InputFile $bootstrapPath -ErrorAction Stop
              Write-Host "Bootstrap script completed."
            }
            else {
              Write-Host "Bootstrap script not found for env $envName, skipping."
            }
          }

      env:
        # Map your per-env Fabric connection string vars to env vars:
        FABRIC_SQL_CONNSTRING_sbox: $(FABRIC_SQL_CONNSTRING_sbox)
        FABRIC_SQL_CONNSTRING_dev:  $(FABRIC_SQL_CONNSTRING_dev)
        FABRIC_SQL_CONNSTRING_test: $(FABRIC_SQL_CONNSTRING_test)
        FABRIC_SQL_CONNSTRING_ithc: $(FABRIC_SQL_CONNSTRING_ithc)
        FABRIC_SQL_CONNSTRING_stg:  $(FABRIC_SQL_CONNSTRING_stg)
        FABRIC_SQL_CONNSTRING_prod: $(FABRIC_SQL_CONNSTRING_prod)



SPN connection test

        - task: PowerShell@2
  displayName: 'Debug: test SQL connection with SqlClient'
  inputs:
    targetType: 'inline'
    script: |
      $connString = $env:FABRIC_SQL_CONNSTRING_dev   # or use $(FABRIC_SQL_CONNSTRING_dev) directly

      if (-not $connString) {
        Write-Error "FABRIC_SQL_CONNSTRING_dev is empty. Aborting."
        exit 1
      }

      Write-Host "Testing SqlClient connection (without printing secrets)..."

      Add-Type -AssemblyName "System.Data"
      $conn = New-Object System.Data.SqlClient.SqlConnection $connString

      try {
        $conn.Open()
        Write-Host "✅ Successfully connected to SQL Server and opened the database."
      }
      catch {
        Write-Error "❌ Failed to connect using SqlClient. Top-level message:"
        Write-Error $_.Exception.Message
        Write-Error ""
        Write-Error "Full exception (for deep details):"
        Write-Error $_.Exception.ToString()
        exit 1
      }
      finally {
        if ($conn.State -eq 'Open') { $conn.Close() }
      }






      - task: PowerShell@2
  displayName: 'Pre-flight: test Fabric SQL connection (dev)'
  inputs:
    targetType: 'inline'
    script: |
      # Use Microsoft.Data.SqlClient (supports AAD Service Principal auth)
      Add-Type -AssemblyName "Microsoft.Data.SqlClient"

      $connString = "$(FABRIC_SQL_CONNSTRING_dev)"

      if (-not $connString -or $connString -like '$(FABRIC_SQL_CONNSTRING*') {
        Write-Error "Connection string variable FABRIC_SQL_CONNSTRING_dev is not set or not expanded."
        exit 1
      }

      # Log a sanitised version so we can see it's correct
      $safe = $connString `
        -replace "User Id=[^;]*","User Id=***" `
        -replace "Password=[^;]*","Password=***"
      Write-Host "Using connection string (sanitised): $safe"

      $conn = New-Object Microsoft.Data.SqlClient.SqlConnection $connString

      try {
        Write-Host "Attempting to open Fabric SQL connection..."
        $conn.Open()
        Write-Host "✅ Successfully connected to Fabric SQL (dev)."
      }
      catch {
        Write-Error "❌ Failed to connect to Fabric SQL (dev)."
        Write-Error $_.Exception.Message
        Write-Error $_.Exception.ToString()
        exit 1
      }
      finally {
        if ($conn.State -eq 'Open') { $conn.Close() }
      }

# 1) Make sure .NET is available on the agent
- task: UseDotNet@2
  displayName: 'Install .NET 8 SDK'
  inputs:
    packageType: 'sdk'
    version: '8.0.x'
    includePreviewVersions: true

# 2) Quick Fabric SQL connection test using your connection string
- task: PowerShell@2
  displayName: 'Quick SQL connection test'
  inputs:
    targetType: 'inline'
    script: |
      # Show dotnet info (just to confirm it's installed)
      Write-Host "=== dotnet --info ==="
      dotnet --info

      # Simple SQL connection test
      Add-Type -AssemblyName "System.Data"
      $cs = "$(FABRIC_SQL_CONNSTRING_dev)"   # make sure this variable is defined
      $conn = New-Object System.Data.SqlClient.SqlConnection $cs

      try {
        Write-Host "Attempting DB connection..."
        $conn.Open()
        Write-Host "✅ Connected to DB."
      }
      catch {
        Write-Error "❌ Failed to connect to DB:"
        Write-Error $_.Exception.Message
        exit 1
      }
      finally {
        if ($conn.State -eq 'Open') { $conn.Close() }
      }

